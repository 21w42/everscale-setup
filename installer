# Everscale Node installer 

#!/usr/bin/env bash

#===============================================================================

## Installer dependencies + useful software
# Ubuntu
ubuntuPackages="net-tools chrony cmake automake pkg-config git libssl-dev clang libzstd-dev gperf libgoogle-perftools-dev nload curl wget jq mc"
# Centos
centosPackages="net-tools chrony openssl-devel clang libzstd-devel gperftools gperftools-devel nload curl wget jq mc"
# Rust
rustVersion="1.58.0"

# Coloring

tLogo=$(tput bold)
tHead=$(tput bold)
tHead2=$(tput smul)
tError=$(tput setaf 1)
tInfo=$(tput setaf 2)
tWarn=$(tput setaf 3)
tComment=$(tput dim)
tLink=$(tput setaf 6)
tUl=$(tput smul)
tHeart=$(tput setaf 1)
tClear=$(tput sgr0)

# Envs

loadEnvs () {

installerConfigDir="/etc/everscale"
installerConfig="${installerConfigDir}/everos-validator_installer.conf"
serviceName="everos-validator"

# Try to load local envs
if test -f "${installerConfig}"; then source "${installerConfig}"; fi

# Everscale root directory
if [[ -z "${installPrefix+x}" ]] || [[ ! ${installPrefix} =~ ${folderRegex} ]]; then
setDir "install directory" "/opt/everscale"
installPrefix=${setDirVar}
setDirVar=null
fi

# Everscale bin dir
binDir="${installPrefix}/bin"
# Everscale build direcory
buildDir="${installPrefix}/build"
# Everscale temp_binaries directory
buildTempDir="${buildDir}/tmp"
# Everscale build direcory src
buildSrcDir="${buildDir}/src"

# Everscale node root directory (data)
if [[ -z "${nodePrefix+x}" ]] || [[ ! ${nodePrefix} =~ ${folderRegex} ]]; then
setDir "node working directory (data)" "/var/lib/everscale/${serviceName}"
nodePrefix=${setDirVar}
setDirVar=null
fi

# Everscale validator log directory
if [[ -z "${logDir+x}" ]] || [[ ! ${logDir} =~ ${folderRegex} ]]; then
setDir "log directory" "/var/log/ever"
logDir=${setDirVar}
setDirVar=null
fi

# Everscale backup direcory
if [[ -z "${backupDir+x}" ]] || [[ ! ${backupDir} =~ ${folderRegex} ]]; then
setDir "backup directory" "${installPrefix}/backup"
backupDir=${setDirVar}
setDirVar=null
fi

# Service binaries
serviceFile="/lib/systemd/system/${serviceName}.service"
serviceBinary="${serviceName}"

# Everscale node subdirs
nodeDbDir="${nodePrefix}/db"
nodeConfigDir="${nodePrefix}/etc"
nodeBocDir="${nodePrefix}/boc"

# Rust directory: rustup
rustup="${installPrefix}/cargo"
# Rust directory: cargo
cargo="${installPrefix}/cargo"

# Github repo of Ever OS node
master_nodeGh="https://github.com/tonlabs/ton-labs-node.git"
master_nodeGhDirName="master_everos-node"
# Github repo of node-tools
master_toolsGh="https://github.com/tonlabs/ton-labs-node-tools.git"
master_toolsGhDirName="master_everos-node-tools"
# Github repo of TONOS-CLI
master_cliGh="https://github.com/tonlabs/tonos-cli.git"
master_cliGhDirName="master_everos-cli"

# Mainnet global config
mainnet_globalConfig="https://raw.githubusercontent.com/tonlabs/main.ton.dev/master/configs/ton-global.config.json"

## Installer VARs
date="$(date '+%Y-%m-%d_%H_%M')"

# Regex validation
folderRegex="^\/([0-9a-zA-Z\.]+)(\/([0-9a-zA-Z\.]+))*\/?$"
digitRegex="^[0-9]+$"
usernameRegex="^[[:lower:]_][[:lower:][:digit:]_-]{2,15}$"

# Node ADNL port (UDP)
# Node ADNL port (UDP) possible range
nodePortMin=1024
nodePortMax=65535
if [[ -z "${nodePort+x}" ]] || [[ ! ${nodePort} =~ ${digitRegex} ]]; then
setPort 30303 ${nodePortMin} ${nodePortMax}
else
validatePortIp
fi

# TMP for misc
tempDir="/var/tmp/everscale"
serviceFileDist="${tempDir}/serviceFileDist"
chronyConfigDist="${tempDir}/chrony"
sysctlConfigDist="${tempDir}/sysctl"
limitsConfigDist="${tempDir}/limits"


# System config files
sysctlConfig="/etc/sysctl.d/101-everscale.conf"
limitsConfig="/etc/security/limits.d/everscale_limits.conf"
pathConfig="/etc/profile.d/everscale.sh"

# Pid of installer
pidDir="/var/run/everscale"
pidFile="${pidDir}/${serviceName}_installer.pid"

# Everscale node user
if [[ -z "${serviceUser+x}" ]] || [[ ! ${serviceUser} =~ ${usernameRegex} ]]; then
setUser "everos"
fi

saveConfig

}

setDir () {

printf "${tHead}* Setting ${1}${tClear}\n
----------------------------------------\n\n"

# usage: setDir $text $varValue

while :; do
read -p "Confirm to set default ${1} is [${tLink}${2}${tClear}]. Press ENTER to accept or enter your value (absolute path): " path

if [ ! -z "${path}" ];then
if [[ $path =~ ${folderRegex} ]]; then
path=`echo "$path" | sed 's/\/$//'`
printf "${tInfo}info: ${tClear}New default ${1} is ${path}\n\n"
setDirVar=${path}
break
else
printf "${tError}error: ${tClear}Path is not valid, please try again or press ENTER to accept default ${1} value: [${2}]\n\n"
fi
else
printf "${tInfo}info: ${tClear}Using default path ${2}\n\n"
setDirVar=${2}
break; fi
done

}

setUser () {

printf "${tHead}* Setting service username${tClear}\n
----------------------------------------\n\n"

# usage: setUser $username

while :; do
read -p "Confirm to set node service user to [${tLink}${1}${tClear}]. Press ENTER to accept or enter your value: " username

if [ ! -z ${serviceUser+x} ]
then
if [[ $username =~ $usernameRegex ]]; then
printf "${tInfo}info: ${tClear}New node process user is ${serviceUser}\n\n"
serviceUser=${username}
break
else
printf "${tError}error: ${tClear}Service username is not valid, please try again or press ENTER to accept [${1}]\n\n"
fi
else
printf "${tInfo}info: ${tClear}Using default username ${1}\n\n"
serviceUser=${1}
break
fi
done

}

setPort () {

printf "${tHead}* Setting service port${tClear}\n
----------------------------------------\n\n"

while :; do
read -p "Confirm to set everscale's default UDP port [ ${tLink}${1}${tClear} ]. Press ENTER to accept or enter your value (${2} - ${3}): " port
[[ $port =~ $digitRegex ]] || { printf "${tInfo}\ninfo: ${tClear}Using default port ${1}\n\n"; nodePort=${1}; break; }
if ((port >= ${2} && port <= ${3})); then
printf "${tInfo}info: ${tClear}New server port number is ${tLink}${port}${tClear}\n\n"
nodePort=${port}
validatePortIp
break
else
printf "${tError}error: ${tClear}Port is out of allowed range, please try again or press ENTER to accept port [ ${tLink}${1}${tClear} ]\n\n"
fi
done

}

validatePortIp () {

printf "${tHead}* Validating port:ip${tClear}\n
----------------------------------------\n\n"

until [ "$(echo "${eNodeAddr}" | grep "\." -o | wc -l)" -eq 3 ] ; do
eNodeAddr="$(curl -s -4 icanhazip.com | xargs)"
done
iNodeAddr="$(hostname -I | xargs)"
NodeAddr=${eNodeAddr}:${nodePort}
printf "Node address: ${tLink}${NodeAddr}${tClear}\n\n"

#Compare internal and external ip addresses
if [[ ! -z ${iNodeAddr+x} ]]; then

if [[ ${iNodeAddr} = ${eNodeAddr} ]]; then
printf "${tInfo}info: ${tClear}Server has public ip address${tClear}\n\n"
else
printf "${tWarn}warn: ${tClear}Server is behind NAT (no real IP address)\n
Script is detected the following addresses

        local ip: ${tLink}${iNodeAddr}${tClear}
     external ip: ${tLink}${eNodeAddr}${tClear}

You need to check if port ${tLink}${nodePort}${tClear}
${tClear}\n"
fi
fi

}

createFolder () {

if [ ! -d "${1}" ]; then mkdir -p ${1}
# if chmod is passed 
if [ ! -z ${3+x} ]; then chmod -R ${3} ${1}; chmod=" with permissions ${3}" ; fi
# chown if we need it
if [ "${2}" -eq 1 ]; then chown -R ${serviceUser}:${serviceUser} ${1}; owner=" with owner ${serviceUser}:${serviceUser}"; fi
printf "${tInfo}info: ${tClear}Created folder ${tLink}${1}${tClear}${chmod}${owner}\n\n" 
fi

}

compareFiles () {

if [ ! -z ${1+x} ] && [ ! -z ${2+x} ] && [ ! -z ${3+x} ]; then

# Usage compareFiles $name $source $target $comand

if [[ -f ${3} ]]; then
# Compute checksum of installed service file
file_MD5=`md5sum ${3} | awk '{print $1 }'`
fileDist_MD5=`md5sum ${2} | awk '{print $1 }'`
if [ "${file_MD5}" != "${fileDist_MD5}" ]; then
printf "${tWarn}warn: ${tClear}You need to update ${1}: [ ${tLink}${3}${tClear} ]\n\n"
while true; do
read -p "Answer "y" if you want to replace it.
Answer y/n:" yn
case $yn in
[Yy]* )
printf "${tInfo}info: ${tClear}replacing...\n\n"
yes | cp -r ${2} ${3}
printf "${tWarn}warn: ${tClear}File is replaced\n\n"
comm="$(${4})"
sleep 2
break
;;
[Nn]* )

break
;;
* ) echo "Answer \"y\" or \"n\""
;;
esac
done
else
printf "${tInfo}info: ${tClear}${1} File is unchanged\n\n"

fi

else
printf "${tInfo}info: ${tClear}Installing file\n\n"
yes | cp -r ${2} ${3}
printf "${tInfo}info: ${tClear}File is installed: [ ${tLink}${3}${tClear} ]\n\n"
comm="$(${4})"
sleep 2
fi

fi

}

saveConfig () {

createFolder ${installerConfigDir} 0 700

cat >$installerConfig <<EOL
# This file will be rewritten each time. You can modify values by hand, but be careful.
installPrefix=${installPrefix}
nodePrefix=${nodePrefix}
logDir=${logDir}
backupDir=${backupDir}
serviceUser=${serviceUser}
nodePort=${nodePort}
EOL

}

# Compare Git versions. We're going to rebuild only if repo is updated

compareGit () {

# Usage compareGit ${1}repoCommonName ${2}remote ${3}locaPath ${4}branch

printf "${tInfo}\ninfo: ${tClear}Comparing ${1} repo${tClear}\n
----------------------------------------\n\n"

Commit=`git ls-remote ${2} ${4} | awk '{print $1 }'`

if [ -d ${buildSrcDir}/${3} ]; then 
cd ${buildSrcDir}/${3} 
CommitL=`git log -1 | grep commit | awk '{print $2 }'`
printf "local / remote commit:\n\n    local commit: ${tLink}${CommitL}${tClear}\n   remote commit: ${tLink}${Commit}${tClear}\n\n"
else
printf "${tWarn}warn: ${tClear}Local ${1} is missing. Doing clone${tClear}\n"
git clone ${2} ${buildSrcDir}/${3} 
CommitL=${Commit}
Init=1
fi

if [[ ! ${Commit} == ${CommitL} ]]; then
printf "${tWarn}warn: ${tClear}Local - Remote repos mismatch. Making clone:\n"
yes | rm -rf ${buildSrcDir}/${3}
git clone ${2} ${buildSrcDir}/${3} 
else
if [[ ! $Init -eq 1 ]]; then printf "${tInfo}info: ${tClear}Local - Remote repos match. No action needed${tClear}\n";fi
fi

}

doCompareGit () {

printf "${tHead}* Comparing and redownloading repos from ${1}${tClear}\n
----------------------------------------\n\n"

case ${1} in

master)

# NODE
compareGit "Everscale node" ${master_nodeGh} ${master_nodeGhDirName} "master"

# NODE-TOOLS
compareGit "Everscale node-tools" ${master_toolsGh} ${master_toolsGhDirName} "master"

# NODE-TOOLS
compareGit "Everscale cli" ${master_cliGh} ${master_cliGhDirName} "master"

;;
esac

}

loadLogo () {

### Logo and creds

# Logo

    printf "\n\n\n${tHead}      *@@@@@@@@@@@@@@          Everscale Ever OS validator node installer
    *@@@@@@@@@@@@@@@@
  *@@@@@@@@@@@@@@@@@@          v 0.24
*@@@@@@@@@@@@@@@@@@@@
             @@@@@@@@          2022-02-15
             @@@@@@@@
             @@@@@@@*
             @@@@@*
             @@@*
             @*${tClear}\n\n"

# Creds

printf "Made by Anatoly Ustinov with ${tHeart}â™¥${tClear}

tg: ${tLink}@ustinovpro${tClear}

----------------------------------------------

Thanks to this repos:

Ever X Labs
${tLink}https://github.com/tonlabs${tClear}

Sergey Tyurin
${tLink}https://github.com/Custler\n\n"
sleep 2

# Changelog

printf "> ${tUl}Changelog${tClear}:
${tComment}
--- 15-02-2022 ------------------------------

- Optimized script structure
- Tested and supported Ubuntu 18.04

--- 02-02-2022 ------------------------------

- Initial release
- Tested and supported Centos 8, Ubuntu 20.04
${tClear}\n\n"
sleep 1

}

rootCheck () {

printf "${tHead}\n* Checking if thes script is running under root user (sudo)${tClear}\n
----------------------------------------\n\n"

if [ "$EUID" -ne 0 ]; then 
printf "${tError}error: ${tClear}Please run installer script as root!\n\n"
exit 1
else printf "${tInfo}info: ${tClear}Root - ok\n\n"
fi
sleep 1

}

osCompliance () {

printf "${tHead}\n* Getting OS info${tClear}\n
----------------------------------------\n\n"

OPSYS=`uname -s`
if [[ "${OPSYS}" == "Linux" ]]; then 
source /etc/os-release
OPSYS="${ID}"
OPVER="${VERSION_ID}"
else printf "${tError}error: ${tClear}Operating system ${OPSYS} is unsupported\n\n"; exit 1; fi
printf "${tInfo}info: ${tClear}Checking packages\n\n"
sleep 1

case $OPSYS in
centos)
printf "${tInfo}info: ${tClear}Centos OS detected\n\n"
export ZSTD_LIB_DIR=/usr/lib64

case $OPVER in
8 | 7)
printf "${tInfo}info: ${tClear}Version $OPVER is supported\n\n"
yum -y update --allowerasing
yum -y group install -y "Development Tools"
yum -y install epel-release
yum -y install ${centosPackages}
printf "${tInfo}\ninfo: ${tClear}Package update is complete\n\n"
;;
*)
printf "${tError}error: ${tClear}Version $OPVER is not supported\n\n"; exit 1
;;
esac
;;

ubuntu)
printf "${tInfo}info: ${tClear}Ubuntu OS detected\n\n"
export ZSTD_LIB_DIR=/usr/lib/x86_64-linux-gnu

case $OPVER in
20.* | 18.*)
printf "${tInfo}info: ${tClear}Version $OPVER is supported\n\n"
apt upgrade -y
apt install -y software-properties-common
apt install -y ${ubuntuPackages}
printf "${tInfo}info: ${tClear}Package update is complete\n\n"
;;
*)
printf "${tWarn}warn: ${tClear}Version $OPVER is not fully tested\n\n"
exit 1
;;
esac
;;

*)
printf "${tError}error: ${tClear}OS ${OPSYS} detected and it's not supported by node installer script\n\n";exit 1
;;
esac

}

rustInstall () {

curl https://sh.rustup.rs -sSf | sh -s -- --default-toolchain ${rustVersion} -q -y --no-modify-path
source ${cargo}/env
rustup install ${rustVersion}
rustup default ${rustVersion}

}

prepareSystem () {

printf "${tHead}\n* Preparing system${tClear}\n
----------------------------------------\n\n"

# Check if ever user exists

printf "${tHead}*${tClear} ${tHead2}Check if system user ${tLink}${serviceUser}${tHead2} exists${tClear}\n
----------------------------------------\n\n"

if id -u "${serviceUser}" >/dev/null 2>&1; then
printf "${tInfo}info: ${tClear}User ${tLink}${serviceUser}${tClear} found\n\n"
else
printf "${tWarn}warn: ${tClear}User ${tLink}${serviceUser}${tClear} not found, creating\n\n"
useradd ${serviceUser}
fi
sleep 1

# Install folders

printf "${tHead}*${tClear} ${tHead2}Creating folders if needed${tClear}\n\n"

createFolder ${installPrefix} 0
createFolder ${binDir} 1 770
createFolder ${buildDir} 0
createFolder ${buildTempDir} 0
createFolder ${buildSrcDir} 0
createFolder ${tempDir} 0
createFolder ${rustup} 0
createFolder ${cargo} 0
createFolder ${backupDir} 0 700
createFolder ${logDir} 1 770
createFolder ${nodePrefix} 1 770
createFolder ${nodeConfigDir} 1 700
createFolder ${nodeDbDir} 1 770
createFolder ${nodeBocDir} 1 700

sleep 1

# Check selinux

printf "${tHead}*${tClear} ${tHead2}Checking SELinux${tClear}\n
----------------------------------------\n\n"

# Check if "getenforce" utility is installed
if [ -x "$(command -v getenforce)" ]; then sel=$(getenforce | xargs)
if [[ ${ignoreSELinux} != "yes" ]];then
if [[ ${sel} == "Disabled"  ||  ${sel} == "Permissive" ]]; then
printf "${tInfo}info: ${tClear}SELinux is ${tLink}Disabled${tClear} status is ${tLink}${sel}${tClear}\n\n"
else printf "${tWarn}warn: ${tClear}SELinux is not ${tLink}Disabled${tClear} so we need to disable it.
You can re-enable and tweak it if you know what you're doing.\n\n
${tError}!!!${tClear} Add ${tUl}ignoreSELinux=yes${tClear} to installer config [ ${tLink}${installerConfig}${tClear} ] to override checkup!
\n\n"
setenforce 0
echo "SELINUX=disabled" > /etc/selinux/config
fi
else
printf "${tWarn}SELinux won't be checked, because if's disabled in config: \n\n
[ ignoreSELinux=yes ] in ${tLink}${installerConfig}${tClear}\n\n"
fi
else printf "${tInfo}info: ${tClear}SELinux is not installed\n\n"
fi

sleep 1

# Sysctl

printf "${tHead}*${tClear} ${tHead2}Doing basic tuning of sysctl${tClear}\n
----------------------------------------\n\n"

cat > ${sysctlConfigDist} <<EOL
# Max files
fs.file-max=6521604

# Less agressive swapping
vm.swappiness=10

# Max files
fs.file-max=6521604

# Network
net.ipv4.conf.default.arp_accept=0  
net.ipv4.conf.all.arp_accept=0  
net.core.rmem_max=56623104  
net.core.wmem_max=56623104  
net.core.rmem_default=56623104  
net.core.wmem_default=56623104  
net.core.optmem_max=40960  
net.ipv4.tcp_rmem=4096 87380 56623104  
net.ipv4.tcp_wmem=4096 65536 56623104  
net.ipv4.tcp_max_syn_backlog=30000  
net.ipv4.tcp_max_tw_buckets=2000000  
net.ipv4.tcp_fin_timeout=10  
net.ipv4.tcp_slow_start_after_idle=0  
net.ipv4.udp_rmem_min=131072  
net.ipv4.udp_wmem_min=131072
EOL

compareFiles "Sysctl file" \
${serviceFileDist} \
${serviceFile} \
"systemctl daemon-reload"

sleep 1

# Limits

cat > ${limitsConfigDist} <<EOL
root - memlock unlimited
$serviceUser - memlock unlimited
EOL

compareFiles "Limits file" \
${limitsConfigDist} \
${limitsConfig}

sleep 1

# Check if path exists

printf "${tHead}*${tClear} ${tHead2}Checking and adding Everscale bin to PATH${tClear}\n
----------------------------------------\n\n"

if [[ -f ${pathConfig} ]]; then
checkPath=$(echo $PATH | grep -c ${binDir})
checkProfile=$(more ${pathConfig} | grep -c ${binDir})
fi

if [[ ${checkPath} -eq 0 || ${checkProfile} -eq 0 ]]
then
cat > ${pathConfig} <<EOL
#Do not edit this file. It will be recreated by installer
export PATH="${binDir}:${PATH}"
EOL
fi
export PATH="${binDir}:${PATH}"

sleep 1

# Check firewall status

printf "${tHead}*${tClear} ${tHead2}Checking default firewall service and adding port allow rule if missing${tClear}\n
----------------------------------------\n\n"

case $OPSYS in
centos)
printf "${tInfo}info: ${tClear}Checking if firewalld is running:\n\n"
if [[ $(firewall-cmd --state) == "running" ]]
then
printf "${tWarn}warn: ${tClear}Firewalld is running. We will check it's rules. You can disable it if you know what are you doing for better perfomance.\n\n"

if [[ $(firewall-cmd --list-ports | grep "${nodePort}" | grep "udp" | awk -F/ '{ print $1 }') -eq ${nodePort} ]]; then 
printf "${tInfo}info: ${tClear}Port ${nodePort}/udp is open\n\n"
else
printf "${tWarn}warn: ${tClear}Adding default rule to firewalld: [ ${tLink}firewall-cmd --zone=public --permanent --add-port=${nodePort}/udp${tClear} ]\n\n"
firewall-cmd --zone=public --permanent --add-port=${nodePort}/udp
printf "${tInfo}info: ${tClear}Reloading rule\n\n"
firewall-cmd --reload
fi

else
printf "${tInfo}info: ${tClear}Firewalld is not running\n\n"

fi
;;

ubuntu)
printf "${tInfo}info: ${tClear}Checking if UFW is running:\n\n"
if [[ $(ufw status) == "active" ]]
then
printf "_warn: ${tInfo}UFW is running. We will check it's rules. You can disable it if you know what are you doing for better perfomance.\n\n"

if [[ $(ufw status | grep "${nodePort}" | grep "udp"  | grep -v "v6" | awk -F/ '{ print $1 }') -eq ${nodePort} ]]; then 
\n\n"Port ${nodePort}/udp is open\n\n"
else
printf "${tWarn}warn: ${tClear}Adding default rule to ufw: [ ${tLink}ufw allow ${nodePort}/udp${tClear} ]\n\n"
ufw allow ${nodePort}/udp
fi
else
printf "${tInfo}info: ${tClear}UFW is not active\n\n"
fi
;;

esac

sleep 1

# Check service file

printf "${tHead}*${tClear} ${tHead2}Checking if service file is present${tClear}\n
----------------------------------------\n\n"
sleep 1


cat >${serviceFileDist} <<EOL
[Unit]
Description=Ever OS Validator Service
After=network.target auditd.service

[Service]
WorkingDirectory=${nodeDbDir}
ExecStart=${binDir}/${serviceBinary} --configs ${nodeConfigDir}
Type=simple
KillMode=process
Restart=always
RestartSec=3
User=${serviceUser}

LimitNOFILE=6521604
LimitNPROC=6521604

StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=${serviceUser}

[Install]
WantedBy=multi-user.target
Alias=${serviceName}.service
EOL

compareFiles "${serviceName} service file" \
${serviceFileDist} \
${serviceFile} \
"systemctl daemon-reload"

sleep 1

# Check time sync

printf "${tHead}*${tClear} ${tHead2}Checking time sync | very important for everscale node!!!${tClear}\n
----------------------------------------\n\n"
sleep 1

printf "${tInfo}\ninfo: ${tClear}installing Chrony as a client\n\n"

cat >$chronyConfigDist <<EOL
pool pool.ntp.org iburst
driftfile /var/lib/chrony/drift
makestep 10 3
rtcsync
EOL

case $OPSYS in
centos)
compareFiles "Chrony config file" \
${chronyConfigDist} \
"/etc/chrony.conf" \
"service chronyd restart"
systemctl enable chronyd
;;

ubuntu)
compareFiles "Chrony config file" \
${chronyConfigDist} \
"/etc/chrony/chrony.conf" \
"service chronyd restart"
systemctl enable chronyd
;;

esac

sleep 1

# Rust install
printf "${tHead}*${tClear} ${tHead2}Installing Rust${tClear}\n
----------------------------------------\n\n"
sleep 1

RUSTUP_HOME=${rustup}
CARGO_HOME=${cargo}
RUSTUP_INIT_SKIP_PATH_CHECK=yes
export RUSTUP_HOME
export CARGO_HOME

rustInstall

sleep 1

}

buildPackages () {

printf "\n\n\n${tHead}* Building and rebuilding packages from: ${tLink}${1}${tClear}\n
================================================================================\n\n"

case ${1} in

master)

source ${cargo}/env

# NODE

printf "${tHead}* Building Everscale node{tClear}\n
----------------------------------------\n\n"

cd ${buildSrcDir}/${master_nodeGhDirName}

git submodule init
git submodule update

sed -i.bak 's%features = \[\"cmake_build\", \"dynamic_linking\"\]%features = \[\"cmake_build\"\]%g' Cargo.toml

# Insert commits in node version

export CARGO_PKG_VERSION=`cargo -V | awk '{print $2}'`
export RUST_VERSION=`rustc -V | awk '{print $2 }'`
export GC_TON_NODE=`git rev-parse HEAD`
export GC_ADNL=`jq -r '."adnl"' < deps_map.json`
export GC_DHT=`jq -r '."dht"' < deps_map.json`
export GC_OVERLAY=`jq -r '."overlay"' < deps_map.json`
export GC_RLDP=`jq -r '."rldp"' < deps_map.json`
export GC_TON_BLOCK=`jq -r '."ton-block"' < deps_map.json`
export GC_TON_BLOCK_JSON=`jq -r '."ton-block-json"' < deps_map.json`
export GC_TON_SDK=`jq -r '."ton-sdk"' < deps_map.json`
export GC_TON_EXECUTOR=`jq -r '."ton-executor"' < deps_map.json`
export GC_TON_TL=`jq -r '."ton-tl"' < deps_map.json`
export GC_TON_TYPES=`jq -r '."ton-types"' < deps_map.json`
export GC_TON_VM=`jq -r '."ton-vm"' < deps_map.json`
export GC_TON_LABS_ABI=`jq -r '."ton-labs-abi"' < deps_map.json`

if RUSTFLAGS="-C target-cpu=native" cargo build --release; then
printf "${tInfo}\ninfo: ${tClear}node is successfully built\n\n"

yes | cp -rf target/release/ton_node ${buildTempDir}/${serviceBinary}
sleep 1
else
printf "${tError}\nerror: ${tClear}node build failed, exit status: $?\n\n"
exit 1
fi


# NODE-TOOLS

printf "${tHead}* Building Everscale node-tools{tClear}\n
----------------------------------------\n\n"

cd ${buildSrcDir}/${master_toolsGhDirName}

git submodule init
git submodule update

if cargo build --release; then
printf "${tInfo}\ninfo: ${tClear}node-tools are successfully built\n\n"
yes | cp -rf target/release/{adnl_ping,adnl_resolve,console,dhtscan,gendht,keygen,keyid,print,zerostate} ${buildTempDir}
sleep 1
else
printf "${tError}\nerror: ${tClear}node-tools build failed, exit status: $?\n\n"
exit 1
fi

# NODE-TOOLS

printf "${tHead}* Building Everscale TONOS-CLI{tClear}\n
----------------------------------------\n\n"

cd ${buildSrcDir}/${master_cliGhDirName}

git submodule init
git submodule update

if cargo build --release; then
printf "${tInfo}\ninfo: ${tClear}TONOS-CLI is successfully built\n\n"
yes | cp -rf target/release/tonos-cli ${buildTempDir}
sleep 1
else
printf "${tError}\nerror: ${tClear}TONOS-CLI build failed, exit status: $?\n\n"
exit 1
fi

;;
esac

}

systemCheckup () {

printf "\n\n\n${tHead}* Installer system checkup${tClear}\n
================================================================================\n\n"

rootCheck

osCompliance

loadEnvs

prepareSystem

}

preparePackages () {

printf "\n\n\n${tHead}* Preparing packages${tClear}\n
================================================================================\n\n"

doCompareGit ${1}

buildPackages ${1}

}

installOrUpdate () {

printf "\n\n\n${tHead}* Install or update packages${tClear}\n
================================================================================\n\n"

}

#===============================================================================

loadLogo

#===============================================================================

systemCheckup

#===============================================================================

preparePackages master
